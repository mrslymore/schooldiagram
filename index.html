<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Room Designer</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: sans-serif;
    }
    canvas {
      border: 1px solid #ccc;
      background: #f8f8f8;
      cursor: default;
    }
    .floating-toolbar {
      position: fixed;
      top: 10px;
      left: 10px;
      background: white;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 10px;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
      z-index: 10;
    }
    .floating-toolbar button,
    .floating-toolbar input {
      margin: 5px 0;
      width: 120px;
    }
    #settingsModal {
      position: fixed;
      top: 20%;
      left: 50%;
      transform: translateX(-50%);
      background: white;
      border: 1px solid #aaa;
      padding: 15px;
      display: none;
      z-index: 100;
    }
  </style>
</head>
<body>

<div class="floating-toolbar">
  <button onclick="addRoom()">‚ûï Add Room</button>
  <button onclick="trashSelected()">üóëÔ∏è Trash</button>
  <button onclick="bringForward()">‚¨ÜÔ∏è Forward</button>
  <button onclick="sendBackward()">‚¨áÔ∏è Backward</button>
  <button onclick="openSettings()">‚öôÔ∏è Settings</button>
  <hr />
  <button onclick="undo()">‚Ü©Ô∏è Undo</button>
  <button onclick="redo()">‚Ü™Ô∏è Redo</button>
  <button onclick="zoomIn()">‚ûï Zoom In</button>
  <button onclick="zoomOut()">‚ûñ Zoom Out</button>
  <hr />
  <button onclick="saveLayout()">üíæ Save</button>
  <button onclick="loadLayout()">üìÇ Load</button>
  <button onclick="downloadJSON()">‚¨áÔ∏è Download</button>
  <input type="file" id="fileInput" style="display:none" onchange="loadFromFile(event)" />
</div>

<div id="settingsModal">
  <h3>Room Settings</h3>
  <label>Color: <input type="color" id="colorInput" /></label><br>
  <label>Font Size: <input type="number" id="fontSizeInput" min="8" max="48" /></label><br>
  <label>Text: <textarea id="roomTextInput" rows="3"></textarea></label><br>
  <button onclick="applySettings()">Apply</button>
  <button onclick="closeSettings()">Close</button>
</div>

<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

let rooms = [];
let history = [];
let redoStack = [];
let selected = [];
let dragging = false;
let resizing = false;
let startX, startY;
let zoom = 1;

let settingsModal = document.getElementById("settingsModal");
let colorInput = document.getElementById("colorInput");
let fontSizeInput = document.getElementById("fontSizeInput");
let roomTextInput = document.getElementById("roomTextInput");

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  draw();
}
window.onresize = resizeCanvas;
resizeCanvas();

function addRoom() {
  saveState();
  rooms.push({
    x: 100, y: 100, w: 150, h: 100,
    text: "New Room",
    color: "#aaf",
    fontSize: 16
  });
  draw();
}

function saveState() {
  history.push(JSON.stringify(rooms));
  if (history.length > 100) history.shift();
  redoStack = [];
}

function undo() {
  if (history.length === 0) return;
  redoStack.push(JSON.stringify(rooms));
  rooms = JSON.parse(history.pop());
  selected = [];
  draw();
}

function redo() {
  if (redoStack.length === 0) return;
  history.push(JSON.stringify(rooms));
  rooms = JSON.parse(redoStack.pop());
  selected = [];
  draw();
}

function draw() {
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.scale(zoom, zoom);
  rooms.forEach((r, i) => {
    ctx.fillStyle = r.color;
    ctx.fillRect(r.x, r.y, r.w, r.h);
    ctx.strokeStyle = selected.includes(i) ? "red" : "black";
    ctx.lineWidth = 2;
    ctx.strokeRect(r.x, r.y, r.w, r.h);
    ctx.fillStyle = "black";
    ctx.font = `${r.fontSize}px sans-serif`;
    wrapText(r.text, r.x + 5, r.y + 20, r.w - 10, r.fontSize + 4);
  });
}

function wrapText(text, x, y, maxWidth, lineHeight) {
  const words = text.split(" ");
  let line = "";
  for (let i = 0; i < words.length; i++) {
    const test = line + words[i] + " ";
    if (ctx.measureText(test).width > maxWidth) {
      ctx.fillText(line, x, y);
      line = words[i] + " ";
      y += lineHeight;
    } else {
      line = test;
    }
  }
  ctx.fillText(line, x, y);
}

canvas.onmousedown = (e) => {
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) / zoom;
  const my = (e.clientY - rect.top) / zoom;
  startX = mx;
  startY = my;

  let found = false;
  rooms.slice().reverse().forEach((r, i) => {
    const index = rooms.length - 1 - i;
    if (
      mx >= r.x && mx <= r.x + r.w &&
      my >= r.y && my <= r.y + r.h
    ) {
      if (!e.shiftKey && !selected.includes(index)) {
        selected = [index];
      } else if (e.shiftKey && !selected.includes(index)) {
        selected.push(index);
      }
      dragging = true;
      found = true;
      draw();
    }
  });

  if (!found && !e.shiftKey) {
    selected = [];
    draw();
  }
};

canvas.onmousemove = (e) => {
  if (!dragging) return;
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) / zoom;
  const my = (e.clientY - rect.top) / zoom;
  const dx = mx - startX;
  const dy = my - startY;
  selected.forEach(i => {
    rooms[i].x += dx;
    rooms[i].y += dy;
  });
  startX = mx;
  startY = my;
  draw();
};

canvas.onmouseup = () => {
  if (dragging) saveState();
  dragging = false;
};

function openSettings() {
  if (selected.length === 0) return;
  const r = rooms[selected[0]];
  colorInput.value = r.color;
  fontSizeInput.value = r.fontSize;
  roomTextInput.value = r.text;
  settingsModal.style.display = "block";
}

function closeSettings() {
  settingsModal.style.display = "none";
}

function applySettings() {
  saveState();
  selected.forEach(i => {
    rooms[i].color = colorInput.value;
    rooms[i].fontSize = parseInt(fontSizeInput.value);
    rooms[i].text = roomTextInput.value;
  });
  closeSettings();
  draw();
}

function trashSelected() {
  if (selected.length === 0) return;
  saveState();
  rooms = rooms.filter((_, i) => !selected.includes(i));
  selected = [];
  draw();
}

function bringForward() {
  selected.forEach(i => {
    if (i < rooms.length - 1) {
      [rooms[i], rooms[i + 1]] = [rooms[i + 1], rooms[i]];
    }
  });
  draw();
}

function sendBackward() {
  selected.forEach(i => {
    if (i > 0) {
      [rooms[i], rooms[i - 1]] = [rooms[i - 1], rooms[i]];
    }
  });
  draw();
}

function zoomIn() {
  zoom = Math.min(zoom + 0.1, 3);
  draw();
}
function zoomOut() {
  zoom = Math.max(zoom - 0.1, 0.3);
  draw();
}

function saveLayout() {
  localStorage.setItem("roomLayout", JSON.stringify(rooms));
  alert("Layout saved to local storage.");
}
function loadLayout() {
  const data = localStorage.getItem("roomLayout");
  if (data) {
    rooms = JSON.parse(data);
    selected = [];
    draw();
  } else {
    alert("No layout found in local storage.");
  }
}

function downloadJSON() {
  const blob = new Blob([JSON.stringify(rooms)], {type: "application/json"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "room_layout.json";
  a.click();
}

function loadFromFile(event) {
  const reader = new FileReader();
  reader.onload = (e) => {
    rooms = JSON.parse(e.target.result);
    selected = [];
    draw();
  };
  reader.readAsText(event.target.files[0]);
}

document.querySelector("button[onclick='loadLayout()']").addEventListener("contextmenu", e => {
  e.preventDefault();
  document.getElementById("fileInput").click();
});
</script>

</body>
</html>
