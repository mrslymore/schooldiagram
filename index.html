<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Room Designer</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    #toolbar {
      background: #ddd;
      padding: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    #canvas {
      flex: 1;
      background: #f5f5f5;
      cursor: default;
    }

    button, input, select {
      font-size: 14px;
      padding: 5px;
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <button onclick="addRoom()">Add Room</button>
    <input id="roomName" placeholder="Room name" />
    <input type="color" id="roomColor" />
    <button onclick="changeSelectedRoomColor()">Change Color</button>
    <button onclick="undo()">Undo</button>
    <button onclick="redo()">Redo</button>
    <button onclick="saveLayout()">Save</button>
    <button onclick="loadLayout()">Load</button>
    <button onclick="exportPNG()">Export PNG</button>
    <button onclick="zoomIn()">Zoom In</button>
    <button onclick="zoomOut()">Zoom Out</button>
  </div>
  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let rooms = [];
    let history = [];
    let future = [];
    let scale = 1;
    let selectedRooms = [];
    let dragging = false;
    let resizing = false;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    let resizeStart = {};
    let multiSelect = false;
    let lastMousePos = { x: 0, y: 0 };

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight - document.getElementById('toolbar').offsetHeight;
      draw();
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    function addRoom() {
      const name = document.getElementById('roomName').value || 'Room';
      const color = document.getElementById('roomColor').value || '#87ceeb';
      const newRoom = {
        id: Date.now(),
        name,
        x: 50,
        y: 50,
        width: 100,
        height: 80,
        color
      };
      rooms.push(newRoom);
      saveHistory();
      draw();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.scale(scale, scale);
      for (let room of rooms) {
        ctx.fillStyle = room.color;
        ctx.fillRect(room.x, room.y, room.width, room.height);
        if (selectedRooms.includes(room)) {
          ctx.strokeStyle = 'red';
          ctx.lineWidth = 2;
          ctx.strokeRect(room.x, room.y, room.width, room.height);
        }
        ctx.fillStyle = 'black';
        ctx.font = '14px sans-serif';
        wrapText(room.name, room.x + 5, room.y + 20, room.width - 10, 16);
      }
      ctx.restore();
    }

    function wrapText(text, x, y, maxWidth, lineHeight) {
      const words = text.split(' ');
      let line = '';
      for (let i = 0; i < words.length; i++) {
        const testLine = line + words[i] + ' ';
        const metrics = ctx.measureText(testLine);
        if (metrics.width > maxWidth && i > 0) {
          ctx.fillText(line, x, y);
          line = words[i] + ' ';
          y += lineHeight;
        } else {
          line = testLine;
        }
      }
      ctx.fillText(line, x, y);
    }

    canvas.addEventListener('mousedown', (e) => {
      const { offsetX, offsetY } = e;
      const x = offsetX / scale;
      const y = offsetY / scale;
      lastMousePos = { x, y };
      multiSelect = e.shiftKey;

      let hitRoom = rooms.find(r => isInside(x, y, r));
      if (hitRoom) {
        if (!selectedRooms.includes(hitRoom)) {
          if (!multiSelect) selectedRooms = [];
          selectedRooms.push(hitRoom);
        }

        const resizingCorner = selectedRooms.length === 1 && isNearCorner(x, y, selectedRooms[0]);
        if (resizingCorner) {
          resizing = true;
          resizeStart = { x, y, ...selectedRooms[0] };
        } else {
          dragging = true;
          dragOffsetX = x;
          dragOffsetY = y;
        }
      } else {
        selectedRooms = [];
      }
      draw();
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!dragging && !resizing) return;
      const { offsetX, offsetY } = e;
      const x = offsetX / scale;
      const y = offsetY / scale;

      const dx = x - lastMousePos.x;
      const dy = y - lastMousePos.y;

      if (resizing && selectedRooms.length === 1) {
        const r = selectedRooms[0];
        r.width = Math.max(20, resizeStart.width + (x - resizeStart.x));
        r.height = Math.max(20, resizeStart.height + (y - resizeStart.y));
      } else if (dragging) {
        for (let r of selectedRooms) {
          r.x += dx;
          r.y += dy;
        }
        lastMousePos = { x, y };
      }

      draw();
    });

    canvas.addEventListener('mouseup', () => {
      if (dragging || resizing) saveHistory();
      dragging = false;
      resizing = false;
    });

    function isInside(x, y, r) {
      return x > r.x && x < r.x + r.width && y > r.y && y < r.y + r.height;
    }

    function isNearCorner(x, y, r) {
      return x > r.x + r.width - 10 && y > r.y + r.height - 10;
    }

    function changeSelectedRoomColor() {
      const color = document.getElementById('roomColor').value;
      for (let r of selectedRooms) {
        r.color = color;
      }
      saveHistory();
      draw();
    }

    function saveHistory() {
      history.push(JSON.stringify(rooms));
      future = [];
    }

    function undo() {
      if (history.length > 1) {
        future.push(history.pop());
        rooms = JSON.parse(history[history.length - 1]);
        selectedRooms = [];
        draw();
      }
    }

    function redo() {
      if (future.length > 0) {
        const state = future.pop();
        history.push(state);
        rooms = JSON.parse(state);
        selectedRooms = [];
        draw();
      }
    }

    function saveLayout() {
      localStorage.setItem('roomLayout', JSON.stringify(rooms));
    }

    function loadLayout() {
  const fileInput = document.getElementById('fileInput');
  fileInput.click();

  fileInput.onchange = (event) => {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const data = JSON.parse(e.target.result);
        if (Array.isArray(data)) {
          clearLayout();
          data.forEach(room => {
            const div = document.createElement('div');
            div.className = 'room';
            div.textContent = room.text;
            div.style.left = room.left;
            div.style.top = room.top;
            div.style.width = room.width;
            div.style.height = room.height;
            div.style.backgroundColor = room.color || '#add8e6';
            div.contentEditable = true;
            makeDraggableResizable(div);
            div.addEventListener('click', (e) => toggleSelection(div, e));
            document.getElementById('classroom').appendChild(div);
          });
        }
      } catch (err) {
        alert('Failed to load layout: Invalid file');
      }
    };
    reader.readAsText(file);
  };
}


    function exportPNG() {
      const tempScale = 2;
      const exportCanvas = document.createElement('canvas');
      exportCanvas.width = canvas.width * tempScale;
      exportCanvas.height = canvas.height * tempScale;
      const exportCtx = exportCanvas.getContext('2d');
      exportCtx.scale(tempScale * scale, tempScale * scale);
      for (let r of rooms) {
        exportCtx.fillStyle = r.color;
        exportCtx.fillRect(r.x, r.y, r.width, r.height);
        exportCtx.fillStyle = 'black';
        exportCtx.font = '14px sans-serif';
        wrapExportText(exportCtx, r.name, r.x + 5, r.y + 20, r.width - 10, 16);
      }
      const link = document.createElement('a');
      link.download = 'layout.png';
      link.href = exportCanvas.toDataURL();
      link.click();
    }

    function wrapExportText(ctx, text, x, y, maxWidth, lineHeight) {
      const words = text.split(' ');
      let line = '';
      for (let i = 0; i < words.length; i++) {
        const testLine = line + words[i] + ' ';
        const metrics = ctx.measureText(testLine);
        if (metrics.width > maxWidth && i > 0) {
          ctx.fillText(line, x, y);
          line = words[i] + ' ';
          y += lineHeight;
        } else {
          line = testLine;
        }
      }
      ctx.fillText(line, x, y);
    }

    function zoomIn() {
      scale *= 1.1;
      draw();
    }

    function zoomOut() {
      scale /= 1.1;
      draw();
    }

    // Init save
    saveHistory();
  </script>
</body>
</html>
