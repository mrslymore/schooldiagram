<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Room Layout Editor with Sidebar</title>
<style>
  /* Basic layout */
  body {
    margin: 0;
    font-family: Arial, sans-serif;
    height: 100vh;
    display: flex;
    flex-direction: column;
  }

  #toolbar {
    background: #eee;
    padding: 8px;
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
    border-bottom: 1px solid #ccc;
  }

  button {
    cursor: pointer;
    padding: 6px 12px;
    user-select: none;
  }

  #canvas-container {
    flex: 1;
    position: relative;
    overflow: auto;
    background: #fafafa;
  }

  #canvas {
    position: relative;
    width: 2000px;
    height: 1400px;
    background: #fff;
    border: 1px solid #ccc;
  }

  .room {
    position: absolute;
    border: 2px solid #0077cc;
    background-color: #80bfff;
    padding: 6px;
    resize: both;
    overflow: auto;
    min-width: 80px;
    min-height: 50px;
    box-sizing: border-box;
    cursor: move;
    user-select: text;
    white-space: pre-wrap; /* multiline */
    font-family: Arial, sans-serif;
    font-size: 14px;
    font-weight: normal;
    color: black;
  }

  .room.selected {
    outline: 3px dashed red;
    z-index: 1000 !important;
  }

  #sidebar {
    position: fixed;
    top: 48px; /* below toolbar */
    right: 0;
    width: 280px;
    height: calc(100vh - 48px);
    background: #fafafa;
    border-left: 1px solid #ccc;
    padding: 12px;
    box-sizing: border-box;
    font-size: 14px;
    display: none;
    overflow-y: auto;
  }

  #sidebar h3 {
    margin-top: 0;
  }

  #sidebar label {
    display: block;
    margin: 10px 0 4px;
  }

  #sidebar input, #sidebar select {
    width: 100%;
    padding: 6px;
    box-sizing: border-box;
  }
</style>
</head>
<body>

<div id="toolbar">
  <button id="addRoomBtn">Add Room</button>
  <button id="trashBtn">üóëÔ∏è Trash Selected</button>
  <button id="bringForwardBtn">‚¨ÜÔ∏è Bring Forward</button>
  <button id="sendBackwardBtn">‚¨áÔ∏è Send Backward</button>
  <button id="undoBtn">‚Ü©Ô∏è Undo</button>
  <button id="redoBtn">‚Ü™Ô∏è Redo</button>
  <button id="zoomInBtn">üîç‚ûï Zoom In</button>
  <button id="zoomOutBtn">üîç‚ûñ Zoom Out</button>
  <button id="saveBtn">üíæ Save</button>
  <button id="loadBtn">üìÇ Load from LocalStorage</button>
  <button id="exportBtn">üñºÔ∏è Export PNG</button>
</div>

<div id="canvas-container">
  <div id="canvas"></div>
</div>

<div id="sidebar">
  <h3>Properties</h3>
  <label for="propFontFamily">Font Family</label>
  <select id="propFontFamily">
    <option value="Arial, sans-serif">Arial</option>
    <option value="Georgia, serif">Georgia</option>
    <option value="'Courier New', monospace">Courier New</option>
    <option value="'Times New Roman', serif">Times New Roman</option>
  </select>

  <label for="propFontSize">Font Size (px)</label>
  <input type="number" id="propFontSize" min="8" max="72" value="14" />

  <label for="propFontWeight">Font Weight</label>
  <select id="propFontWeight">
    <option value="normal">Normal</option>
    <option value="bold">Bold</option>
    <option value="lighter">Lighter</option>
  </select>

  <label for="propTextColor">Text Color</label>
  <input type="color" id="propTextColor" value="#000000" />

  <label for="propBgColor">Background Color</label>
  <input type="color" id="propBgColor" value="#80bfff" />
</div>

<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
<script>
(() => {
  const canvas = document.getElementById('canvas');
  const canvasContainer = document.getElementById('canvas-container');

  const addRoomBtn = document.getElementById('addRoomBtn');
  const trashBtn = document.getElementById('trashBtn');
  const bringForwardBtn = document.getElementById('bringForwardBtn');
  const sendBackwardBtn = document.getElementById('sendBackwardBtn');
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  const zoomInBtn = document.getElementById('zoomInBtn');
  const zoomOutBtn = document.getElementById('zoomOutBtn');
  const saveBtn = document.getElementById('saveBtn');
  const loadBtn = document.getElementById('loadBtn');
  const exportBtn = document.getElementById('exportBtn');

  const sidebar = document.getElementById('sidebar');
  const propFontFamily = document.getElementById('propFontFamily');
  const propFontSize = document.getElementById('propFontSize');
  const propFontWeight = document.getElementById('propFontWeight');
  const propTextColor = document.getElementById('propTextColor');
  const propBgColor = document.getElementById('propBgColor');

  let rooms = [];
  let selectedRooms = new Set();

  // Undo/Redo stacks hold snapshots of rooms data (array of JSON serializable objects)
  let undoStack = [];
  let redoStack = [];

  // Zoom scale and canvas size for zooming by expanding canvas container
  let scale = 1;
  let baseCanvasWidth = 2000;
  let baseCanvasHeight = 1400;

  // -- UTILS --

  function saveState() {
    const state = rooms.map(r => serializeRoom(r));
    undoStack.push(state);
    redoStack = [];
    updateUndoRedoButtons();
    saveToLocalStorage();
  }

  function restoreState(state) {
    clearCanvas();
    state.forEach(data => {
      const room = createRoomElement(data);
      canvas.appendChild(room);
      rooms.push(room);
    });
    selectedRooms.clear();
    updateSelectionUI();
    saveToLocalStorage();
  }

  function updateUndoRedoButtons() {
    undoBtn.disabled = undoStack.length <= 1;
    redoBtn.disabled = redoStack.length === 0;
  }

  function saveToLocalStorage() {
    try {
      const state = rooms.map(r => serializeRoom(r));
      localStorage.setItem('roomLayout', JSON.stringify(state));
    } catch {}
  }

  function loadFromLocalStorage() {
    try {
      const data = JSON.parse(localStorage.getItem('roomLayout'));
      if (data && Array.isArray(data)) {
        restoreState(data);
        undoStack = [];
        redoStack = [];
        saveState();
      }
    } catch {}
  }

  // -- ROOM SERIALIZATION --

  function serializeRoom(room) {
    return {
      left: room.style.left,
      top: room.style.top,
      width: room.style.width,
      height: room.style.height,
      text: room.innerText,
      fontFamily: room.style.fontFamily,
      fontSize: room.style.fontSize,
      fontWeight: room.style.fontWeight,
      color: room.style.color,
      backgroundColor: room.style.backgroundColor,
      zIndex: room.style.zIndex || '0',
    };
  }

  // -- ROOM CREATION --

  function createRoomElement(data = {}) {
    const room = document.createElement('div');
    room.classList.add('room');
    room.contentEditable = true;
    room.style.left = data.left || '50px';
    room.style.top = data.top || '50px';
    room.style.width = data.width || '120px';
    room.style.height = data.height || '80px';
    room.style.fontFamily = data.fontFamily || 'Arial, sans-serif';
    room.style.fontSize = data.fontSize || '14px';
    room.style.fontWeight = data.fontWeight || 'normal';
    room.style.color = data.color || 'black';
    room.style.backgroundColor = data.backgroundColor || '#80bfff';
    room.style.zIndex = data.zIndex || '0';
    room.innerText = data.text || 'Room';

    makeDraggableAndResizable(room);
    attachRoomEvents(room);

    return room;
  }

  // -- SELECTION --

  function selectRoom(room, additive = false) {
    if (!additive) {
      selectedRooms.forEach(r => r.classList.remove('selected'));
      selectedRooms.clear();
    }
    selectedRooms.add(room);
    room.classList.add('selected');
    updateSidebar();
  }

  function deselectRoom(room) {
    selectedRooms.delete(room);
    room.classList.remove('selected');
    updateSidebar();
  }

  function toggleRoomSelection(room, additive = false) {
    if (selectedRooms.has(room)) {
      deselectRoom(room);
    } else {
      selectRoom(room, additive);
    }
  }

  function clearSelection() {
    selectedRooms.forEach(r => r.classList.remove('selected'));
    selectedRooms.clear();
    updateSidebar();
  }

  function updateSelectionUI() {
    rooms.forEach(room => {
      if (selectedRooms.has(room)) room.classList.add('selected');
      else room.classList.remove('selected');
    });
    updateSidebar();
  }

  // -- DRAG & RESIZE --

  function makeDraggableAndResizable(room) {
    let isDragging = false;
    let dragOffsetX = 0;
    let dragOffsetY = 0;

    room.addEventListener('mousedown', e => {
      if (e.target !== room) return;

      if (!e.shiftKey && !selectedRooms.has(room)) {
        clearSelection();
      }
      selectRoom(room, e.shiftKey);

      isDragging = true;
      dragOffsetX = e.clientX - room.offsetLeft;
      dragOffsetY = e.clientY - room.offsetTop;

      e.preventDefault();
    });

    window.addEventListener('mousemove', e => {
      if (!isDragging) return;
      const x = e.clientX - dragOffsetX;
      const y = e.clientY - dragOffsetY;

      const draggedRoom = [...selectedRooms][0];
      if (!draggedRoom) return;

      const deltaX = x - draggedRoom.offsetLeft;
      const deltaY = y - draggedRoom.offsetTop;

      selectedRooms.forEach(r => {
        const newLeft = r.offsetLeft + deltaX;
        const newTop = r.offsetTop + deltaY;
        r.style.left = newLeft + 'px';
        r.style.top = newTop + 'px';
      });
    });

    window.addEventListener('mouseup', e => {
      if (isDragging) {
        isDragging = false;
        saveState();
      }
    });

    room.addEventListener('input', e => {
      saveState();
    });

    room.addEventListener('mousedown', e => {
      e.stopPropagation();
    });
  }

  // -- SIDEBAR --

  function updateSidebar() {
    if (selectedRooms.size === 0) {
      sidebar.style.display = 'none';
      return;
    }
    sidebar.style.display = 'block';

    const arr = Array.from(selectedRooms);
    const first = arr[0];

    function uniformProperty(prop) {
      const val = first.style[prop];
      return arr.every(r => r.style[prop] === val) ? val : '';
    }

    propFontFamily.value = uniformProperty('fontFamily') || 'Arial, sans-serif';
    propFontSize.value = uniformProperty('fontSize') ? parseInt(uniformProperty('fontSize')) : 14;
    propFontWeight.value = uniformProperty('fontWeight') || 'normal';
    propTextColor.value = uniformProperty('color') || '#000000';
    propBgColor.value = uniformProperty('backgroundColor') || '#80bfff';
  }

  function applySidebarChanges() {
    selectedRooms.forEach(room => {
      room.style.fontFamily = propFontFamily.value;
      room.style.fontSize = propFontSize.value + 'px';
      room.style.fontWeight = propFontWeight.value;
      room.style.color = propTextColor.value;
      room.style.backgroundColor = propBgColor.value;
    });
    saveState();
  }

  propFontFamily.addEventListener('change', applySidebarChanges);
  propFontSize.addEventListener('change', applySidebarChanges);
  propFontWeight.addEventListener('change', applySidebarChanges);
  propTextColor.addEventListener('input', applySidebarChanges);
  propBgColor.addEventListener('input', applySidebarChanges);

  // -- LAYERING --

  function bringForward() {
    selectedRooms.forEach(room => {
      let z = parseInt(room.style.zIndex || 0);
      z++;
      room.style.zIndex = z;
    });
    saveState();
  }

  function sendBackward() {
    selectedRooms.forEach(room => {
      let z = parseInt(room.style.zIndex || 0);
      z = Math.max(0, z - 1);
      room.style.zIndex = z;
    });
    saveState();
  }

  // -- TRASH --

  function trashSelected() {
    selectedRooms.forEach(room => {
      canvas.removeChild(room);
      rooms = rooms.filter(r => r !== room);
    });
    selectedRooms.clear();
    updateSidebar();
    saveState();
  }

  // -- ZOOM --

  function zoomIn() {
    scale = Math.min(5, scale * 1.2);
    updateCanvasSize();
  }
  function zoomOut() {
    scale = Math.max(0.2, scale / 1.2);
    updateCanvasSize();
  }

  function updateCanvasSize() {
    canvas.style.width = baseCanvasWidth * scale + 'px';
    canvas.style.height = baseCanvasHeight * scale + 'px';
  }

  // -- SAVE / LOAD --

  function saveLayout() {
    const data = rooms.map(r => serializeRoom(r));
    const json = JSON.stringify(data, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = 'room-layout.json';
    a.click();

    URL.revokeObjectURL(url);
  }

  function loadLayout() {
    loadFromLocalStorage();
  }

  // -- EXPORT PNG --

  exportBtn.addEventListener('click', () => {
    // Use html2canvas to export the #canvas div as PNG
    html2canvas(canvas, {scale: 2}).then(canvasImg => {
      const link = document.createElement('a');
      link.download = 'room-layout.png';
      link.href = canvasImg.toDataURL('image/png');
      link.click();
    });
  });

  // -- ADD ROOM --

  addRoomBtn.addEventListener('click', () => {
    const room = createRoomElement();
    canvas.appendChild(room);
    rooms.push(room);
    clearSelection();
    selectRoom(room);
    saveState();
  });

  // -- TRASH --

  trashBtn.addEventListener('click', () => {
    if (selectedRooms.size === 0) return alert('No rooms selected');
    if (!confirm(`Delete ${selectedRooms.size} selected room(s)?`)) return;
    trashSelected();
  });

  // -- LAYERING --

  bringForwardBtn.addEventListener('click', () => {
    bringForward();
  });

  sendBackwardBtn.addEventListener('click', () => {
    sendBackward();
  });

  // -- UNDO / REDO --

  undoBtn.addEventListener('click', () => {
    if (undoStack.length <= 1) return;
    const current = undoStack.pop();
    redoStack.push(current);
    const prev = undoStack[undoStack.length - 1];
    restoreState(prev);
    updateUndoRedoButtons();
  });

  redoBtn.addEventListener('click', () => {
    if (redoStack.length === 0) return;
    const next = redoStack.pop();
    undoStack.push(next);
    restoreState(next);
    updateUndoRedoButtons();
  });

  // -- ZOOM --

  zoomInBtn.addEventListener('click', () => zoomIn());
  zoomOutBtn.addEventListener('click', () => zoomOut());

  // -- SELECTION VIA CANVAS CLICK (deselect) --

  canvas.addEventListener('mousedown', e => {
    if (e.target === canvas) {
      clearSelection();
    }
  });

  // -- CLEAR CANVAS --

  function clearCanvas() {
    rooms.forEach(r => canvas.removeChild(r));
    rooms = [];
  }

  // -- INITIAL LOAD --

  loadFromLocalStorage();
  updateCanvasSize();

  // Save initial empty state so undo works properly
  if (undoStack.length === 0) saveState();

})();
</script>

</body>
</html>
