<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Room Layout Editor</title>
  <style>
    body { font-family: sans-serif; margin: 0; padding: 0; }
    #toolbar {
      display: flex;
      gap: 8px;
      padding: 10px;
      background: #eee;
      border-bottom: 1px solid #ccc;
    }
    canvas {
      border: 1px solid #ccc;
      cursor: crosshair;
    }
    button, input[type="file"] {
      padding: 6px 12px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <button onclick="addRoom()">Add Room</button>
    <button onclick="undo()">Undo</button>
    <button onclick="redo()">Redo</button>
    <button onclick="saveLayout()">Save JSON</button>
    <input type="file" id="loadInput" accept=".json" onchange="loadLayout(event)" style="display:none">
    <button onclick="document.getElementById('loadInput').click()">Load JSON</button>
    <button onclick="exportPNG()">Export PNG</button>
    <button onclick="zoomIn()">Zoom In</button>
    <button onclick="zoomOut()">Zoom Out</button>
  </div>
  <canvas id="canvas" width="1200" height="800"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let rooms = [];
    let undoStack = [], redoStack = [];
    let selectedRooms = [];
    let dragging = false, offsetX = 0, offsetY = 0;
    let scale = 1;

    const saveState = () => {
      undoStack.push(JSON.stringify(rooms));
      redoStack = [];
    };

    const restoreState = (stackFrom, stackTo) => {
      if (stackFrom.length === 0) return;
      stackTo.push(JSON.stringify(rooms));
      rooms = JSON.parse(stackFrom.pop());
      selectedRooms = [];
      draw();
    };

    function undo() { restoreState(undoStack, redoStack); }
    function redo() { restoreState(redoStack, undoStack); }

    function addRoom() {
      saveState();
      rooms.push({ x: 50, y: 50, width: 100, height: 80, name: "Room", color: "#ffcc00" });
      draw();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.scale(scale, scale);

      for (const room of rooms) {
        ctx.fillStyle = room.color;
        ctx.fillRect(room.x, room.y, room.width, room.height);
        ctx.strokeStyle = selectedRooms.includes(room) ? 'blue' : 'black';
        ctx.lineWidth = 2;
        ctx.strokeRect(room.x, room.y, room.width, room.height);

        ctx.fillStyle = 'black';
        ctx.font = '14px sans-serif';
        const lines = room.name.split("\n");
        lines.forEach((line, i) => {
          ctx.fillText(line, room.x + 4, room.y + 20 + i * 16);
        });
      }

      ctx.restore();
    }

    function saveLayout() {
      const dataStr = JSON.stringify(rooms, null, 2);
      const blob = new Blob([dataStr], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'room-layout.json';
      a.click();
      URL.revokeObjectURL(url);
    }

    function loadLayout(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = e => {
        try {
          saveState();
          rooms = JSON.parse(e.target.result);
          selectedRooms = [];
          draw();
        } catch (err) {
          alert("Invalid JSON file");
        }
      };
      reader.readAsText(file);
    }

    function exportPNG() {
      const link = document.createElement('a');
      link.download = 'layout.png';
      link.href = canvas.toDataURL();
      link.click();
    }

    function zoomIn() {
      scale *= 1.1;
      draw();
    }

    function zoomOut() {
      scale /= 1.1;
      draw();
    }

    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: (e.clientX - rect.left) / scale,
        y: (e.clientY - rect.top) / scale
      };
    }

    canvas.addEventListener('mousedown', e => {
      const { x, y } = getMousePos(e);
      selectedRooms = rooms.filter(r => x >= r.x && x <= r.x + r.width && y >= r.y && y <= r.y + r.height);
      if (selectedRooms.length > 0) {
        dragging = true;
        offsetX = x - selectedRooms[0].x;
        offsetY = y - selectedRooms[0].y;
      }
      draw();
    });

    canvas.addEventListener('mousemove', e => {
      if (!dragging || selectedRooms.length === 0) return;
      const { x, y } = getMousePos(e);
      for (let room of selectedRooms) {
        room.x = x - offsetX;
        room.y = y - offsetY;
      }
      draw();
    });

    canvas.addEventListener('mouseup', () => {
      if (dragging) saveState();
      dragging = false;
    });

    // Keyboard shortcuts: delete and multi-line rename
    document.addEventListener('keydown', e => {
      if (e.key === 'Delete') {
        saveState();
        rooms = rooms.filter(r => !selectedRooms.includes(r));
        selectedRooms = [];
        draw();
      } else if (e.key === 'Enter' && selectedRooms.length === 1) {
        const newName = prompt("Enter new room name (use \n for multiple lines):", selectedRooms[0].name);
        if (newName != null) {
          saveState();
          selectedRooms[0].name = newName;
          draw();
        }
      }
    });

    draw();
  </script>
</body>
</html>
